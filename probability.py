"""A module providing some utilities for calculations related to probability."""

import sys
from numpy import sign
from math import pi, e, sqrt
from graph import Graph
from random import gauss, random

class Gaussian:
	"""A class used to represent Gaussian distributions"""


	def __init__(self, mean, variance, probability):
		"""Creates a new Gaussian object

		The new Gaussian object will have the specified mean and variance.  Its
		height will be such that the integral of the Gaussian is equal to the
		specified probability."""
		#Note; the height calculation is only accurate for Gaussians over
		#one dimension.  This does not affect the accuracy of the program's
		#calculations, but could cause visual renderings to be slightly off.
		self.mean = mean
		self.variance = variance
		self.height = probability/(sqrt(2*pi)*sqrt(variance[0]))
		self.probability = probability

	def __call__(self, point):
		"""Returns the numerical value of the Gaussian at the specified point.

		Point shall be a tuple of numerical coordinates."""
		#Since gaussians are functions, they can be evaluated at given points.
		#This isn't useful for calculating probabilities but is useful for
		#visually representing gaussians.

		#For a one dimensional gaussian, the function is equal to
		# ae^(-((x-b)^2)/(2c^2)), where a is the height, b is the mean, and c is
		#the standard deviation of the gaussian.

		#Currently this class represents multi-dimensional gaussians as a set of
		#one dimensional gaussians, one for each axis.  In this case, this
		#function will return the minimum value of the set of values associated
		#with each one-dimentional gaussian at the coordinate on the
		#corresponding axis.  In more than one dimension, this is actually not
		#correct
		return min([self.height*e**((-(point[x]-self.mean[x])**2)/(2*(sqrt(self.variance[x])**2))) for x in range(len(point))])

	def generatePoint(self):
		"""Generates a random point whose distribution corresponds with this Gaussian.

		The point is represented as a tuple of numerical coordinates."""
		return tuple(gauss(self.mean[x], sqrt(self.variance[x])) for x in range(len(self.mean)))

	def probabilityOf(self, x, granularity=1):
		"""Returns the probability that this Gaussian would generate points close to the specified point.

		More specifically, it returns the probability that all coordinates of a point
		generated by the gaussian would be within granularity/2 units of the
		specified point."""
		#One thing that's pretty important to note is that the probability of a
		#Gaussian generating any particular point is always zero.  For instance,
		#if you have a Gaussian whose mean is 4 and whose variance is, say, 1,
		#the probability of it generating exactly 4 is exactly zero.  This seems
		#paradoxical, since 4 is where the height of the curve appears, and the
		#probability of the Gaussian generating points around four is indeed very
		#high.  However, the probability of it generating any particular value is
		#zero.  This is because there are an infinite number of numbers in the
		#range of the distribution, and if each of them had a nonzero probability,
		#the sum of probabilities would be infinite, which is impossible.  However,
		#it is possible to talk about the probability that a point generated by a
		#Gaussian will fall within a particular range.  So, while the probability of
		#any Gaussian generating exactly four is always zero, we can still ask
		#about the probability that a point generated by the Gaussian will fall
		#between 3.5 and 4.5.  These ranges do in fact have nonzero probabilities.
		#Those probabilities in turn are calculated using the integral of the
		#generating Gaussian function.
		res = 1
		for index in range(0, len(self.mean)):
			z1 = ((x[index]-(granularity/2))-self.mean[index])/(sqrt(self.variance[index]))
			z2 = ((x[index]+(granularity/2))-self.mean[index])/(sqrt(self.variance[index]))
			res = res * (standardNormalCDF(z2)-standardNormalCDF(z1))
		return res

	@staticmethod
	def fromPoints(dim, points, prob):
		"""Returns a Gaussian with the same mean and variance as the dict of weighted points"""
		#This is used to iteratively improve the algorithm's guess at where
		#the actual gaussians lie.  It weights all the points on the graph
		#according to how likely they are to belong to each gaussian.  Then
		#it creates new gaussians from the weighted points and repeats until
		#the gaussians converge on a particular location.
		mean = [sum([point[x]*probability for point, probability in points.items()])/sum(points.values()) for x in range(dim)]
		var = [(sum([(abs(point[x]-mean[x]))*probability for point, probability in points.items()])/sum(points.values()))**2 for x in range(dim)]
		return Gaussian(tuple(mean), tuple(var), prob)

def probabilitiesOfGaussiansGiven(dim, gaussians, points):
	"""For each point, returns the probability that that point would have been generated by each gaussians

	That is, given that a given point has been generated, it returns the probability for each gaussian that
	that gaussian was the one that generated the point."""
	#Currently, this function can only handle Gaussian distributions.  It would be
	#possible to abstract it to support any class of distribution.  This may be
	#necessary if we end up using more than just Gaussian distributions.
	results = {}
	for point in points:
		#For each point, we calculate the probability that it comes from each
		#gaussian.  This makes use of Bayes' theorem.
		results[point] = {}
		#px represents the total probability that x would have been generated
		#by any of the gaussians.
		px = sum([g.probabilityOf(point)*g.probability for g in gaussians])
		for gaussian in gaussians:
			#pxgg represents the probability that the particular gaussian in question
			#would generate x. I.E. The probability that a point would fall at x given
			#that it was generated by gaussian g.
			pxgg = gaussian.probabilityOf(point)
			#The probability that any given point will have been generated by the
			#gaussian in question as opposed to some other gaussian.
			pg = gaussian.probability
			#Here's Bayes:
			results[point][gaussian] = (pxgg*pg)/px
	return results


def standardNormalCDF(x):
	"""Returns the probability that a random variable generated by the standard normal distribution would be less than x."""
	#The standard normal distribution is a special Gaussian distribution with
	#a mean of 0 and a standard deviation of 1.  The CDF (cumulative distribution
	#function) of this function is related to that of every other Gaussian
	#distribution, and is useful in calculating the probability that a point
	#generated by a gaussian will fall within a given range.
	return (1/2)*(1+(sign(x)*(1-(e**((-2*x**2)/pi)))**(1/2)))

#The main function essentially generates a random test case where two random
#Gaussian distributions generate 500 points each.  Then, the algorithm is put to
#work using those points to approximate the original gaussians given only the
#points and to attempt to classify those points into their appropriate gaussians.
def main(argv):
	#Generate a couple of gaussians with random means and random gaussians.
	#Set their probabilities to reflect the fact that they will each generate
	#half of the total points.
	gen1 = Gaussian((random()*30+10,), (random()*15+5,), 0.5)
	gen2 = Gaussian((random()*30+10,), (random()*15+5,), 0.5)
	#Create a list of 1000 points, where 500 were generated by each of the above
	#Gaussians.
	points = [gen1.generatePoint() for x in range(500)] + [gen2.generatePoint() for x in range(500)]

	#This is where the algorithm begins

	#Create a couple of gaussians to represent guesses as to where the original
	#gaussians might have been.
	gaussians = [Gaussian((1,), (50,), 0.5), Gaussian((2,), (50,), 0.5)]
	#The algorithm will iterate thirty times, each time improving its guess as to
	#where the original gaussians lie.
	for x in range(30):
		#Just graphics stuff; used to output visual data
		g = Graph(-20,0,60,0.4)
		g.addFunction(gen1, (90,90,90))
		g.addFunction(gen2, (90,90,90))
		g.addFunction(gaussians[0], (255,0,0))
		g.addFunction(gaussians[1], (0,0,255))
		for point in points:
			g.addPoint((point[0],0))
		g.renderToFile("graph"+"%02d" % (x)+".png", 640, 480)
		#For each of our guess gaussians and for every point we were supplied,
		#evaluate the probability, given that point x was generated by some
		#gaussian, that it would have been generated by this particular gaussian.
		probabilities = probabilitiesOfGaussiansGiven(1, gaussians, points)
		#Recalculate the positions of the gaussians so that they will lie closer
		#to the points that were likely to have been generated by them.
		gaussians = [Gaussian.fromPoints(1, {point: probs[gaussian] for point, probs in probabilities.items()}, gaussian.probability) for gaussian in gaussians]
	print([(gen1.mean, gen1.variance, gen1.probability), (gen2.mean, gen2.variance, gen2.probability)])
	print(gaussians)

if __name__ == "__main__":
	main(sys.argv)
